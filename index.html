<!DOCTYPE HTML>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
    <title>Test</title>
    <link rel="icon" href="data:," />
    <style>
        body {
            text-align: center;
        }

        div[contenteditable="true"] {
            width: 800px;
            max-width: 100%;
            height: 400px;
            border: 1px solid #ccc;
            box-sizing: border-box;
            margin: 10px auto;
            padding: 10px;
            text-align: left;
            vertical-align: middle;
            line-height: 1.5;
            font-family: Arial, Microsoft Yahei;
            font-size: 14px;
            display: inline-block;
            word-break: break-all;
            white-space: break-spaces;
            overflow-wrap: break-word;
            overflow-anchor: none;
            overflow: auto;
            cursor: text;
        }

        div[contenteditable="true"] img {
            cursor: pointer;
            max-width: 100%;
        }

        ._editor_file_pending {
            margin: 0 2px;
            padding: 1px;
            outline: 1px dashed black;
            outline-offset: -1px;
            vertical-align: middle;
            opacity: 0.2;
        }
    </style>
</head>

<body>
    <a href="javascript:Editor.undo();">Undo</a>
    <a href="javascript:Editor.redo();">Redo</a>
    <a href="javascript:Editor.sweep();">Sweep</a>
    <a href="javascript:;"
        onclick="Editor.dom.innerText=Editor.dom.innerHTML.replace(/&/g, '&amp;').replace( />/g,'&gt;').replace(/</g, '&lt;' )">Logger</a>
    <br />
    <div contenteditable="true"></div>
    <script>
        class Editor {
            // IOS Prev \n
            // Reduce Word Undo
            // Picker Upload
            static dom;
            static css;
            static ver = 0;
            static rev = [];
            static tap = true;
            static box = [];
            static async item(f) {
                this.box.push(f);
                const fid = this.box.length;
                const cvs = document.createElement("canvas");
                cvs.width = 150;
                cvs.height = this.css.textHeight;
                const ctx = cvs.getContext("2d");
                ctx.font = this.css.font;
                ctx.fillStyle = "black";
                ctx.textBaseline = "middle";
                let tag = f.name || "#" + fid;
                if (ctx.measureText(tag).width > cvs.width) {
                    const max = cvs.width - ctx.measureText("...").width;
                    let bsl = 0;
                    let bsr = tag.length;
                    while (bsl <= bsr) {
                        const mid = Math.floor((bsl + bsr) / 2);
                        if (ctx.measureText(tag.slice(0, mid)).width > max) { bsr = mid - 1; }
                        else { bsl = mid + 1; }
                    }
                    tag = tag.slice(0, bsr) + "...";
                }
                ctx.fillText(tag, 0, cvs.height / 2);
                return URL.createObjectURL(await new Promise(r => cvs.toBlob(r))) + "#" + fid; // URL.revokeObjectURL
            };
            static async pour(e) {
                if (e) { e.preventDefault(); }
                let txt = "";
                if (e.dataTransfer?.types.includes("text/html")) {
                    const tmp = e.dataTransfer.getData("text");
                    txt = new Range().createContextualFragment(e.dataTransfer.getData("text/html")
                        .replace(/\v/g, "\n\t")
                        .replace(/\<img\s+.*?src=\"([^"]+)\".*?\>/gi, "\v$1\v")
                        .replace(/(\<(?:option|td|th)(?:\>|\s+.*?\>))/gi, " $1")
                        .replace(/(\<(?:address|article|aside|blockquote|br|caption|dd|details|dialog|div|dl|dt|fieldset|figcaption|figure|footer|form|h\d|header|hr|iframe|legend|li|main|nav|ol|p|pre|ruby|section|summary|table|tbody|tfoot|thead|tr|ul)(?:\>|\s+.*?\>))/gi, "\n$1")
                    ).textContent
                        .replace(/^[^\S\v]+/, tmp.match(/^[^\S\n]*(\n*)/)[1])
                        .replace(/[^\S\v]+$/, tmp.match(/(\n*)[^\S\n]*$/)[1])
                }
                else if (e.dataTransfer?.types.includes("text/plain")) {
                    txt = e.dataTransfer.getData("text/plain");
                }
                else if (e.dataTransfer?.types.includes("Files")) {
                    txt = (await Promise.all(
                        Array.from(e.dataTransfer.items || []) //stackoverflow.com/questions/3590058
                            .flatMap(i => (i.webkitGetAsEntry()?.isFile === false) ? [] : (i.getAsFile() || []))
                            .sort((a, b) => new Intl.Collator(undefined, { numeric: true, sensitivity: 'base' }).compare(a.name, b.name))
                            .map(async f => "\v" + await this.item(f) + "\v"))
                    ).join("\n")
                }
                const doc = new DocumentFragment();
                const reg = new RegExp(/\v(?:blob|data):[^#]*?\v/gi);
                const pre = await Promise.all((txt.match(reg) || []).map(async m => {
                    const u = m.slice(1, m.length - 1);
                    const i = await fetch(u).then(r => r.blob()).then(b => new File([b], "")).then(f => this.item(f));
                    if (u.startsWith("blob:")) { URL.revokeObjectURL(u); }
                    return i;
                }));
                doc.replaceChildren(new Range().createContextualFragment(await txt
                    .replace(/[\u00A0-\u9999<>\&\'\"\\]/gi, _ => "&#" + _.charCodeAt(0) + ";")
                    .replace(reg, m => "<img class=\"_editor_file_pending\" src=\"" + pre.shift() + "\" alt=\"\" />")
                    .replace(/\v(blob:.*?(#.*?))\v/gi, "<img class=\"_editor_file_pending\" src=\"$1\" alt=\"\" />")
                    .replace(/\v(.*?)\v/gi, "<img src=\"$1\" alt=\"\" />")
                    .replace(/\r\n|\r/g, "\n")
                    .replace(/\n{3,}/g, "\n\n")));
                const l = doc.lastChild;
                const r = this.range(e);
                r.rg.deleteContents();
                r.rg.insertNode(doc);
                if (l) { r.rg.setStartAfter(l); }
                this.slide(r.rg);
                r.sl.removeAllRanges();
                r.sl.addRange(r.rg);
                this.save(e);
            };
            static dump(e) {
                if (e) { e.preventDefault(); }
                const use = this.rev[this.ver - 1];
                if (!use) { return; }
                this.dom.focus();
                this.dom.replaceChildren(use.dom.cloneNode(true));
                const r = this.range(e);
                if (use.startIndex < 0) {
                    if (use.startOffset >= this.dom.childNodes.length) {
                        r.rg.setStartAfter(this.dom.lastChild);
                    } else {
                        r.rg.setStartBefore(this.dom.childNodes[use.startOffset]);
                    }
                } else {
                    r.rg.setStart(this.dom.childNodes[use.startIndex], use.startOffset);
                }
                if (use.endIndex < 0) {
                    if (use.endOffset >= this.dom.childNodes.length) {
                        r.rg.setEndAfter(this.dom.lastChild);
                    } else {
                        r.rg.setEndBefore(this.dom.childNodes[use.endOffset]);
                    }
                } else {
                    r.rg.setEnd(this.dom.childNodes[use.endIndex], use.endOffset);
                }
                this.slide(r.rg);
                r.sl.removeAllRanges();
                r.sl.addRange(r.rg);
                this.save(e);
            };
            static save(e) {
                if (e) { e.preventDefault(); }
                this.dom.focus();
                if (this.dom.innerText.slice(-1) !== "\n") { this.dom.appendChild(new Text("\n")); }
                if (!this.tap && e?.inputType && !e.inputType.startsWith("history")) { this.rev.splice(this.ver); this.tap = true; }
                if (!this.tap || (e?.inputType && ["insertCompositionText", "deleteCompositionText", "insertFromComposition"].includes(e.inputType))) { return; }
                const child = Array.from(this.dom.childNodes);
                const rgNow = this.range(e).rg;
                const rgAll = new Range();
                rgAll.selectNodeContents(this.dom);
                this.rev.push({
                    startIndex: child.indexOf(rgNow.startContainer),
                    startOffset: rgNow.startOffset,
                    endIndex: child.indexOf(rgNow.endContainer),
                    endOffset: rgNow.endOffset,
                    dom: child.length ? rgAll.cloneContents() : rgAll.createContextualFragment("\n")
                });
                this.ver = this.rev.length;
            };
            static undo(e) {
                if (e) { e.preventDefault(); }
                if (this.ver < 2) { return; }
                this.tap = false;
                this.ver--;
                this.dump(e);
            };
            static redo(e) {
                if (e) { e.preventDefault(); }
                if (this.ver === this.rev.length) { return; }
                this.tap = false;
                this.ver++;
                this.dump(e);
            };
            static range(e) {
                this.dom.focus();
                const sl = document.getSelection();
                if (e && e.clientX && e.clientY) {
                    if (document.caretPositionFromPoint) { return { sl, rg: document.caretPositionFromPoint(e.clientX, e.clientY) } }
                    if (document.caretRangeFromPoint) { return { sl, rg: document.caretRangeFromPoint(e.clientX, e.clientY) } }
                }
                return { sl, rg: sl.rangeCount ? sl.getRangeAt(0) : new Range() }
            };
            static slide(r) {
                const n = new Text("\u200D");
                r = r.cloneRange();
                r.insertNode(n);
                const d = r.getBoundingClientRect().bottom - (this.dom.getBoundingClientRect().top + this.dom.clientTop + this.dom.clientHeight - parseInt(this.css.paddingBottom));
                n.remove();
                if (d > 0) { this.dom.scrollTop += d; }
            };
            static watch(s) {
                this.dom = document.querySelector(s);
                this.dom.setAttribute("translate", "no");
                this.dom.setAttribute("spellcheck", "false");
                this.css = window.getComputedStyle(this.dom);
                const rct = document.createElement("span");
                rct.innerText = "\u200D";
                this.dom.appendChild(rct);
                this.css.textHeight = rct.getClientRects()[0].height;
                this.dom.removeChild(rct);
                this.dom.addEventListener("beforeinput", async e => {
                    if (e.inputType.startsWith("format") || (!e.inputType.startsWith("delete") && ![
                        "historyUndo", "historyRedo",
                        "insertLineBreak", "insertParagraph",
                        "insertText", "insertCompositionText", "insertFromComposition",
                        "insertFromDrop", "insertFromYank", "insertFromPaste", "insertFromPasteAsQuotation", "insertReplacementText",
                    ].includes(e.inputType))) { e.preventDefault(); return; }
                    if (["insertLineBreak", "insertParagraph"].includes(e.inputType)) {
                        const r = this.range(e);
                        r.rg.deleteContents();
                        r.rg.insertNode(new Text("\n"));
                        r.rg.collapse(false);
                        this.slide(r.rg);
                        r.sl.removeAllRanges();
                        r.sl.addRange(r.rg);
                        this.save(e);
                    }
                    else if (["insertFromDrop", "insertFromYank", "insertFromPaste", "insertFromPasteAsQuotation", "insertReplacementText"].includes(e.inputType)) {
                        await this.pour(e);
                    }
                    else if (e.inputType === "historyUndo") {
                        this.undo(e);
                    }
                    else if (e.inputType === "historyRedo") {
                        this.redo(e);
                    }
                }, false);
                this.dom.addEventListener('input', async e => {
                    this.save(e);
                }, false);
                this.dom.addEventListener('compositionend', async e => {
                    e.inputType = "endComposition";
                    this.save(e);
                }, false);
                this.dom.addEventListener('drop', async e => {
                    if (e.dataTransfer?.types?.length === 1 && e.dataTransfer.types[0] === "Files") {
                        e.inputType = "dropFiles";
                        await this.pour(e);
                    }
                }, false);
                ['dragenter', 'dragover', 'drop'].forEach(_ => {
                    window.addEventListener(_, async e => e.preventDefault(), false);
                    this.dom.addEventListener(_, async e => e.stopPropagation(), false);
                });
                this.dom.addEventListener('keydown', async e => {
                    e.stopImmediatePropagation();
                    if ((e.ctrlKey || e.metaKey) && ((e.shiftKey && e.keyCode === 90) || e.keyCode === 89)) { this.redo(e); }
                    else if ((e.ctrlKey || e.metaKey) && e.keyCode === 90) { this.undo(e); }
                }, false);
                this.save(window.event);
            };
            static sweep() {
                this.ver = 0;
                this.rev = [];
                this.tap = true;
            };
        };
        Editor.watch("div[contenteditable='true']");
    </script>
</body>

</html>
